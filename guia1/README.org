* Guia 1
** funciones utiles
#+BEGIN_SRC emacs-lisp
    (defun replace-results-line ()
      "Reemplaza '#+RESULTS:' por '*RESULTS:*' en el buffer actual."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (search-forward "#+RESULTS:" nil t)
          (replace-match "*RESULTS:*" nil nil))))

    (defun my-org-block-strip-leading-whitespace ()
    "Elimina espacios y tabulaciones al inicio de cada línea en el bloque Org actual.
  Se busca el bloque Org en el que está el cursor y, si se encuentra, se eliminan
  todos los espacios y tabulaciones que preceden a cualquier otro carácter en cada línea."
    (interactive)
    (let* ((element (org-element-at-point))
           (beg (org-element-property :begin element))
           (end (org-element-property :end element)))
      (if (and beg end)
          (save-excursion
            (goto-char beg)
            (while (re-search-forward "^[ \t]+" end t)
              (replace-match "")))
        (message "No se encontró un bloque Org en el punto."))))
  (defun my-org-block-hindent-indent ()
  "Llama a `my-org-block-strip-leading-whitespace`, activa `hindent-mode` y luego,
para cada línea del bloque Org actual, simula la pulsación de TAB con `indent-for-tab-command`."
  (interactive)
  ;; Primero elimina los espacios y tabs al inicio de cada línea en el bloque.
  (my-org-block-strip-leading-whitespace)
  ;; Activa hindent-mode.
  (hindent-mode 1)
  (let* ((element (org-element-at-point))
         (beg (org-element-property :begin element))
         (end (org-element-property :end element)))
    (if (and beg end)
        (save-excursion
          (goto-char beg)
          (while (< (point) end)
            (indent-for-tab-command)
            (forward-line 1)))
      (message "No se encontró un bloque Org en el punto."))))




#+END_SRC

#+RESULTS:
: my-org-block-hindent-indent

** Ejericio1


Considerar las siguientes definiciones de funciones:
1) Cuál es el tipo de cada función? (Suponer que todos los números son de tipo Float).

El tipo esta especificado dentro de cada funcion
max2 (x, y)
#+BEGIN_SRC haskell :results output
  :{
  max2:: (Float, Float) -> Float
  max2 (x, y) | x >= y = x
              | otherwise = y
  :}
  max2 (2, 4)
#+END_SRC

#+RESULTS:
: 4.0


normaVectorial (x, y)
#+BEGIN_SRC haskell :results output
  :{
  normaVectorial:: (Float, Float) -> Float
  normaVectorial (x, y) = sqrt (x^2 + y^2)
  :}
  normaVectorial (2, 2)
#+END_SRC

#+RESULTS:
: 2.828427

subtract
#+BEGIN_SRC haskell :results output
:{
subtract:: Float -> Float -> Float
subtract = flip (-)
:}
subtract 8 2
#+END_SRC

*RESULTS:*
: -6.0

predecesor
#+BEGIN_SRC haskell :results output
  :{
    subtract:: Float -> Float -> Float
     subtract = flip (-)

     predecesor:: Float -> Float
     predecesor = subtract 1

  :}
  predecesor 8
#+END_SRC

*RESULTS:*
: 7.0



evaluarEnCero

#+BEGIN_SRC haskell :results output
  :{
    subtract:: Float -> Float -> Float
    subtract = flip (-)

    predecesor:: Float -> Float
    predecesor = subtract 1

    evaluarEnCero:: (Float -> Float) -> Float
    evaluarEnCero = \f -> f 0

  :}
  evaluarEnCero(predecesor)
#+END_SRC

*RESULTS:*
: -1.0

dosVeces
#+BEGIN_SRC haskell :results output
  :{
    dosVeces:: (Float -> Float) -> (Float -> Float)
    dosVeces = \f -> f . f

    sumarDos:: Float -> Float
    sumarDos x = x + 2
  :}

   dosVeces sumarDos 5
#+END_SRC

*RESULTS:*
: 9.0

flipAll = map flip
#+BEGIN_SRC haskell :results output
  :{
     flipAll:: [a -> b -> c] -> [b -> a -> c]
     flipAll = map flip

  :}
#+END_SRC

*RESULTS:*




flipRaro = flip flip
#+BEGIN_SRC haskell :results output
  :{
    flipRaro:: e -> (d -> e -> f) -> d -> f
    flipRaro = flip flip

  :}
#+END_SRC

*RESULTS:*

ii. Indicar cuáles de las funciones anteriores no están curricadas. Para cada una de ellas, denir la función
curricada correspondiente. Recordar dar el tipo de la función.
** Ejercicio 2
i. Definir la función curry, que dada una función de dos argumentos,
devuelve su equivalente currificada.

#+BEGIN_SRC haskell :results output
  :{
  curry :: ((a,b) -> c) -> a -> b -> c
  curry f x y = f (x,y)

  -- curry f = \x -> \y -> f (x,y)
  -- curry f = \x y -> f (x,y)
  :}

#+END_SRC

ii. Dfnir la función uncurry, que dada una función curricada de dos argumentos, devuelve su versión no
curricada equivalente. Es la inversa de la anterior.
#+begin_src haskell :results output
  {:
  uncurry :: (a -> b -> c) -> (a,b) -> c
  uncurry f = \(x,y) -> f x y
  }:
#+end_src

iii. Se podría definir una función curry^n, que tome una función de un número arbitrario de argumentos y
devuelva su versión currificada?
*Sugerencia*: pensar cuál sería el tipo de la función
** Ejercicio 3
i. Redefinir usando *foldr* las funciones *sum*, *elem*, *(++)*, *filter* y *map*.
*** sum
#+begin_src haskell :results output
    :{
    sum:: Num b => [b] -> b
    sum [] = 0
    sum (b:bs) = b + sum bs
    :}

    :{
    sumF::Num b => [b] -> b
    sumF = foldr (\x resRec -> x + resRec )  0
    :}
  sumF [1, 2, 3]

#+end_src

#+RESULTS:
: 6
*** Elem
#+begin_src haskell :results output
:{
elem:: Eq a => a -> [a] -> Bool
elem _ [] = Falsey
elem a (x:xs) = (x == a) || (elem a xs)
:}


:{
elemF:: Eq a => a -> [a] -> Bool
elemF a = foldr (\x resRec -> ((x == a) || resRec)) (False)
:}

elem 0 [1, 0]
elemF 7 [8, 9, 7]
elemF 7 [8, 9]

elem 0 [8, 9]
#+end_sr

#+RESULTS:
: True
: True
: False
*** (++)
#+begin_src haskell :results output code
  :{
  (++):: [a] -> [a] -> [a]
  (++) [] a = a
  (++) (x:xs) a = x : ((++) xs a)
  :}

  :{
  (+++):: [a] -> [a] -> [a]
  (+++) xs ys = foldr (\x resRec -> x : resRec) ys xs
  :}

  ((+++) [5, 4] [6, 7])

#+end_src

#+RESULTS:
#+begin_src haskell
[5,4,6,7]
#+end_src
*** filter

#+begin_src haskell :results output code

    :{
      filter:: ( a -> Bool) -> [a] -> [a]
      filter _ [] = []
      filter pred (x:xs) = if (pred x) then x : (filter pred xs) else (filter pred xs)
  :}
  :{
      filter:: ( a -> Bool) -> [a] -> [a]
      filter pred xs = foldr(\x resRec -> if (pred x) then (x:resRec) else resRec) [] xs
  :}
    filter (even) [1, 2, 3, 4, 5]

#+end_src

#+RESULTS:
#+begin_src haskell
[2,4]
#+end_src
*** Map
#+begin_src haskell :results output
  :{
     map::
  :}

#+end_src

#+RESULTS:
: map :: (a -> b) -> [a] -> [b]

ii. Definir la función mejorSegún :: (a -> a -> Bool) -> [a] -> a, que
devuelve  el máximo elemento de la lista según una función de
comparación, utilizando foldr1. Por ejemplo, maximum = mejorSegún (>).
*** MejorSegun
#+begin_src haskell :results output code
     :{
      mejorSegun :: (a -> a -> Bool) -> [a] -> a
      mejorSegun _ [x] = x
      mejorSegun pred (x:xs) = if (pred x (mejorSegun pred xs)) then x else mejorSegun pred xs
     :}

      :{
      mejorSegun2 :: (a -> a -> Bool) -> [a] -> a
      mejorSegun2 pred = foldr1 mejor
       where
        mejor x res
          | pred x res = x
          | otherwise = res
      :}

  :{
    mejorSegun3 :: (a -> a -> Bool) -> [a] -> a
    mejorSegun3 pred = foldr1 (\x res -> case pred x res of
                                        True  -> x
                                        False -> res)

  :}
   (mejorSegun2 (>) [1, 5, 10, 8, 4])
   (mejorSegun3 (>) [1, 88, 10, 8, 4])

#+end_src

#+RESULTS:
#+begin_src haskell
10
88
#+end_src


iii. Definir la función sumasParciales :: Num a => [a] -> [a], que dada una lista de números devuelve
otra de la misma longitud, que tiene en cada posición la suma parcial de los elementos de la lista original
desde la cabeza hasta la posición actual. Por ejemplo, sumasParciales
[1,4,-1,0,5] ; [1,5,4,4,9].
#+begin_src haskell :results output code
  :{
  sumasParciales :: Num a => [a] -> [a]
  sumasParciales [x] = [x]
  sumasParciales xs = sumasParciales' 0 xs
    where
      sumasParciales' _ [] = []
      sumasParciales' acc (y:ys) = [acc + y] ++ sumasParciales' (acc+y) ys

  :}

  :{
    sumasParciales1 :: Num a => [a] -> [a]
    sumasParciales1 xs = sumasParciales1' 0 xs
     where
     sumasParciales1' = foldr (\acc (y:res) -> [acc+y] ++ res) []
  :}
  sumasParciales [1,4,-1,0,5]

#+end_src

#+RESULTS:
#+begin_src haskell
<interactive>:15:24-44: error:
    • Couldn't match expected type: [a] -> [a]
                  with actual type: [a0]
    • The function ‘sumasParciales1'’
      is applied to two value arguments,
        but its type ‘t0 a0 -> [a0]’ has only one
      In the expression: sumasParciales1' 0 xs
      In an equation for ‘sumasParciales1’:
          sumasParciales1 xs
            = sumasParciales1' 0 xs
            where
                sumasParciales1' = foldr (\ acc (y : res) -> [...] ++ res) []
    • Relevant bindings include
        xs :: [a] (bound at <interactive>:15:19)
        sumasParciales1 :: [a] -> [a] (bound at <interactive>:15:3)
[1,5,4,4,9]
#+end_src


iv. Denir la función sumaAlt, que realiza la suma alternada de los elementos de una lista. Es decir, da como
resultado: el primer elemento, menos el segundo, más el tercero, menos el cuarto, etc. Usar foldr.
v. Hacer lo mismo que en el punto anterior, pero en sentido inverso (el último elemento menos el anteúltimo,
etc.). Pensar qué esquema de recursión conviene usar en este caso.
** Ejercicio 6
*** a
Definir la función sacarUna :: Eq a => a -> [a] -> [a], que dados un
elemento y una lista devuelve el resultado de eliminar de la lista la primera aparición del elemento(si
está presente).
#+begin_src haskell :results output code
    :{
    sacarUna:: Eq a => a -> [a] -> [a]
    sacarUna a [] = []
    sacarUna a (x:xs) = if (a == x) then xs else x:(sacarUna a xs)
    :}

    :{
    recr :: (a -> [a] -> b -> b) -> b -> [a] -> b
    recr f z [] = z
    recr f z (x : xs) = f x xs (recr f z xs)

    sacarUnaR:: Eq a => a -> [a] -> [a]
    sacarUnaR a = recr (\x xs resc ->  if (a == x) then xs else x:resc) []
    :}
  --  sum 0 [1, 2, 3]

#+end_src
